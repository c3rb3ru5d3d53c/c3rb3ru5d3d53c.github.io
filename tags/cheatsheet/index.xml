<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Cheatsheet - Tag - Malware Hell</title><link>https://c3rb3r3u5d3d53c.github.io/tags/cheatsheet/</link><description>Cheatsheet - Tag - Malware Hell</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>c3rb3r3u5d3d53c@gmail.com (c3rb3r3u5d3d53c)</managingEditor><webMaster>c3rb3r3u5d3d53c@gmail.com (c3rb3r3u5d3d53c)</webMaster><lastBuildDate>Mon, 26 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://c3rb3r3u5d3d53c.github.io/tags/cheatsheet/" rel="self" type="application/rss+xml"/><item><title>ANGR Python Scripting Cheatsheet</title><link>https://c3rb3r3u5d3d53c.github.io/2023/06/angr-python-cheatsheet/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate><author>c3rb3ru5d3d53c</author><guid>https://c3rb3r3u5d3d53c.github.io/2023/06/angr-python-cheatsheet/</guid><description>ANGR Python CheatSheet Symbolic execution is a technique that involves the systematic exploration of all possible paths in a program&amp;rsquo;s code using abstract syntax trees (ASTs).
Assembly as an AST Placeholder
Without Branching In the following example, the assembly code moves the value of 5 into the 32-bit register eax, moves the value 7 into the 32-bit register ebx, then adds both eax and ebx together with the result being stored in eax.</description></item><item><title>Ghidra Python Scripting Cheatsheet</title><link>https://c3rb3r3u5d3d53c.github.io/2023/02/ghidra-python-cheatsheet.en.md/</link><pubDate>Sat, 04 Feb 2023 00:00:00 +0000</pubDate><author>c3rb3ru5d3d53c</author><guid>https://c3rb3r3u5d3d53c.github.io/2023/02/ghidra-python-cheatsheet.en.md/</guid><description><![CDATA[This is a cheatsheet I use for Ghidra scripting.
NOTE: Some of these functions use each other ðŸ˜„
User Input 1 askFile(&#39;Title&#39;, &#39;Okay&#39;).toString() Get Python Bytes from Address 1 2 def get_bytes(address, size): return bytes(map(lambda b: b &amp; 0xff, getBytes(address, size))) Get Section Bytes (Program Tree) 1 2 3 def get_section_bytes(section_name): section = getMemoryBlock(section_name) return get_bytes(section.getStart(), section.getSize()) Get Executable Path 1 currentProgram.getExecutablePath() Get Program Start Address 1 currentProgram.getMinAddress() Get Program End Address 1 currentProgram.]]></description></item><item><title>Reverse Engineering CheatSheet</title><link>https://c3rb3r3u5d3d53c.github.io/2022/06/cheatsheet/</link><pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate><author>c3rb3ru5d3d53c</author><guid>https://c3rb3r3u5d3d53c.github.io/2022/06/cheatsheet/</guid><description><![CDATA[SHA256 Files in Folder 1 find . -maxdepth 1 -type f | while read i; mv $i (sha256sum $i | grep -Po &#39;^[a-f0-9]+&#39;); end Download Hashes from Clipboard 1 xclip -o -s -c | xargs -I {} echo &#34;vt download {}&#34; | parallel -j 8 {} Binlex Top 10 Traits 1 find samples/ -type f | while read i; binlex -i $i | jq -r &#39;trait&#39; | sort | uniq; end | sort | uniq -c | sort -rn | head -10 Capture PCAP 1 tshark -i lo -F libpcap -w (date +&#34;%Y-%m-%d&#34;).]]></description></item><item><title>KVM Malware Lab Guide</title><link>https://c3rb3r3u5d3d53c.github.io/2022/06/kvm-malware-lab/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate><author>c3rb3ru5d3d53c</author><guid>https://c3rb3r3u5d3d53c.github.io/2022/06/kvm-malware-lab/</guid><description>This is my guide for setting up your very own malware lab using KVM.
Before you start, this guide assumes you have an AirVPN subscription or another equivalent one, which provides a .ovpn file.
NOTE: I like to have internet enabled on my analysis VMs and this comes with extra security considerations and potential risk if you do not perform the setup correctly. It is recommended that you have your KVM host machine on a DMZ.</description></item></channel></rss>