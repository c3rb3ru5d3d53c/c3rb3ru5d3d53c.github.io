<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rustlang on Malware Hell</title><link>https://c3rb3ru5d3d53c.github.io/tags/rustlang/</link><description>Recent content in rustlang on Malware Hell</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2022 &lt;a href="https://twitter.com/c3rb3ru5d3d53c">c3rb3ru5d3d53c&lt;/a></copyright><lastBuildDate>Thu, 04 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://c3rb3ru5d3d53c.github.io/tags/rustlang/index.xml" rel="self" type="application/rss+xml"/><item><title>A Reverse Engineering Guide for Rust Binaries</title><link>https://c3rb3ru5d3d53c.github.io/documents/malware-reversing-rust/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://c3rb3ru5d3d53c.github.io/documents/malware-reversing-rust/</guid><description>Introduction The Rust programming language is like rust on a vehicle for malware analysts and reverse engineers. The adoption of the language by malware authors spreads like cancer the longer it is in active development. This is due to convenient static linking and support for many operating systems, yielding a binary with little to no dependencies. These features are excellent for the distribution of malware. Every time we need to reverse engineer a Rust binary, we would rather embrace the sweet release of death.</description></item></channel></rss>